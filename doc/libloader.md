# MiraiCP libLoader

libLoader是MiraiCP用于插件管理的中间件。本文档主要解释MiraiCP libloader对插件的加载、卸载、重载以及线程模型。

>  运行时，一个MiraiCP插件有三种状态，未加载、加载但未启用、已启用。

实际运行时，kotlin端（主）线程（mcl或MiraiCP-loader）加载libLoader，并启动loader线程。Loader线程仅用于管理插件。

主线程将配置信息传递给libLoader中的函数。这之后libLoader将为每一个插件建立一个新线程，并绑定该插件。即，如果有两个MiraiCP插件存在，那么正常情况下至少有4个线程在运行（主、loader、两个插件）。

加载插件时，libloader使用动态链接的方式加载插件（动态链接库）的符号。一个正确的插件，至少需要有四个`extern "C"`的符号存在：*入口函数、事件函数、config函数、退出函数*。这些已经在MiraiCP代码中实现了。

### 加载

在**加载（load）**时（实际上执行了动态链接），如果动态链接库正常链接的话，按顺序执行下面步骤：

* 静态区的代码会被初始化并运行
* 检查上述四个符号的存在性；如果符号检查失败，将会卸载这个动态链接库，检查成功则完成加载。

此时入口函数`enrollPlugin`尚未调用。

> 加载时的线程只会是kt线程或loader线程。

### 启用

加载结束后，如果是程序初次启动，libloader将**启用（enable）**插件。启用插件将：

* 分配线程，并绑定至插件
* 在新线程中调用入口函数，调用结束后休眠，等待event到达
* event到达时线程会广播事件，回调调用结束后继续休眠

>  请勿在入口函数中写死循环，这将导致无法接收event。

当Mirai事件发生时，kt端线程将调用libLoader中的函数，将event*并发地*派发给loader中注册的每个已经启用的插件线程。

### 禁用

运行时可以**禁用（disable）**某个插件。禁用操作会导致：

* 插件绑定的线程执行退出函数
* 完成后线程将被detach并结束运行

插件此时进入*加载但未启用*状态。但插件静态区的代码将仍然存在，但是无法接收任何event，也无法发送消息。在这之后重新启用该插件，会得到原本的静态区的信息。请在退出函数中释放所有的非静态资源以及detach插件自行创建的线程。

### 卸载

同样地，运行时可以**卸载（unload）**某插件。卸载操作会导致：

* 若插件是启用状态，先**禁用**
* 卸载动态链接库，静态区的内容也会被卸载

Mirai进程正常退出时，所有插件会被卸载。

> 注意，如果您在插件中建立了新线程，应当在禁用阶段（即退出函数中）将该线程结束掉。否则，这将导致卸载时出现Segmentation Fault.

### 重载

运行时还可以重载某插件。重载时可选择是否同时启用，包括以下操作：

* 先**卸载**
* **加载**（若文件仍然存在，否则失败）
* 若选择了同时启用，则**启用**

重载一般用于运行时热更新插件等操作。

### loader API

我们提供了一组loader API，用于插件的管理。这些api包括一些底层api（如事件操作，底层日志函数），在不清楚它的行为的情况下请不要调用。除此之外的api包括：获取插件列表，加载、卸载、重载、禁用、启用插件等操作，后面五个操作仅限在配置文件中设置了管理权限的插件调用。这些api调用后*目前*不会返回执行是否成功的信息。

loader API的存在同时保证了被禁用的插件无法进行任何Mirai操作。

### 插件中的多线程

插件中可以使用多线程。首先，我们相信您拥有充足的C++的多线程知识。

请注意，MiraiCP并不提供插件创建的其他线程的管理，libloader仅限于管理与插件绑定的那个线程。在插件被禁用时，为了保证您的程序不发生意料之外的问题或直接崩溃，请终结掉所有新建的线程的执行。

并且，为了保证新线程的异常能被MiraiCP的异常捕获、广播机制正常捕获并广播，可以使用我们提供的继承了`std::thread`的类`MiraiCPNewThread`。该函数行为和`std::thread`相同，除了有自带的异常捕获以外没有区别；使用该类就可以不用在自己的线程任务中捕获异常了。

