# MiraiCP libLoader

libLoader是MiraiCP用于插件管理的中间件。本文档主要解释MiraiCP libloader对插件的加载、卸载、重载以及线程模型。

### 简介

>  运行时，一个MiraiCP插件有三种状态：
>
>  * 未加载
>  * 加载但未启用
>  * 已启用

实际运行时，kotlin端（主）线程（mcl或MiraiCP-loader）加载libLoader，并启动loader线程。Loader线程仅用于管理插件。

主线程将配置信息传递给libLoader中的函数。之后libLoader将启动一个线程池，线程数与当前的操作环境支持的最大并发数一致。

libloader使用动态链接的方式加载插件（动态链接库）。一个正确的插件，至少需要有四个非隐藏的`extern "C"`的符号存在：*入口函数、事件函数、config函数、退出函数*。这些已经在MiraiCP代码中实现了。

后续的启用、禁用、事件等，都会被派发到线程池中完成。

### 加载

在**加载（load）**时（实际上执行了动态链接），如果动态链接库正常链接的话，按顺序执行下面步骤：

* 静态区的代码会被初始化并运行
* 检查上述四个符号的存在性；如果符号检查失败，将会卸载这个动态链接库，检查成功即完成加载。

此时入口函数`enrollPlugin`不会被调用。

> 加载时的线程只会是kt线程或loader线程。

### 启用

加载结束后，如果是程序初次启动，libloader将**启用（enable）**插件。启用插件将：

* 启用插件任务被派发至线程池
* 在接到该任务的工作线程中调用入口函数，调用结束后继续休眠，等待下一个任务

>  请勿在入口函数中写死循环，这将导致线程池中一个工作线程被永久阻塞。

### 事件

当Mirai事件发生时，kt端线程将调用libLoader中的函数，将event*并发地*派发给loader中注册的每个已经启用的插件线程。

* 事件任务被派发到线程池
* 在接到该任务的工作线程中调用事件函数，调用结束后继续休眠，等待下一个任务

> 请勿在事件注册的回调中写死循环，这将导致每次该类型事件发生时，线程池中一个工作线程被永久阻塞。

### 禁用

运行时可以**禁用（disable）**某个插件。禁用操作会导致：

* 禁用插件任务被派发至线程池

* 在接到该任务的工作线程中调用退出函数，调用结束后继续休眠，等待下一个任务

> 请勿在退出函数中写死循环，这将导致线程池中一个工作线程被永久阻塞。

插件此时进入*加载但未启用*状态。插件静态区、堆上的数据将仍然存在，但是无法接收任何event，也无法发送消息（我们建议在退出函数中清理掉堆上的内存）。在这之后重新启用该插件，会得到原本的静态区的数据。请在退出函数中释放所有的非静态资源以及detach插件自行创建的线程。

### 卸载

同样地，运行时可以**卸载（unload）**某插件。卸载操作会导致：

* 若插件是已启用状态，先**禁用**，阻塞等待禁用完成
* **卸载**动态链接库，静态区的内容也会被卸载

Mirai进程正常退出时，所有插件会被卸载。

> 注意，如果您在插件中建立了新线程，应当在禁用阶段（即退出函数中）将该线程结束掉。否则，这有很大可能导致卸载时出现内存访问异常。

### 重载

运行时还可以重载某插件。重载时可选择是否同时启用，包括以下操作：

* 先**卸载**
* **加载**（若文件仍然存在，否则失败）
* 若选择了同时启用，则**启用**

重载一般用于运行时热更新插件等操作。

### loader API

我们提供了一组loader API，用于插件的管理。这些api包括一些底层api（如事件操作，底层日志函数），如果不清楚它的行为，请不要调用。除此之外的api包括：获取插件列表，加载、卸载、重载、禁用、启用插件等操作，后面五类操作仅限在配置文件中设置了**具有管理权限**的插件调用。这些api调用后*目前*不会返回执行是否成功的信息。

loader API的存在同时保证了被禁用的插件无法进行任何Mirai操作。

### 插件中的多线程

插件中可以使用多线程。首先，我们相信您拥有充足的C++的多线程知识。

我们假设插件的线程分为两类，插件绑定的线程为插件主线程，插件新建的线程为插件子线程。请注意，libloader并不提供插件创建的子线程的管理，libloader仅管理插件主线程。在插件被禁用时，为了保证您的程序不发生意料之外的问题或直接崩溃，请终结掉所有新建的线程的执行。

并且，为了保证新线程的异常能被MiraiCP的异常捕获、广播机制正常捕获并广播，以及当发生致命错误时不会将整个MiraiCP程序带崩，可以使用我们提供的继承了`std::thread`的类`MiraiCPNewThread`。该类行为和`std::thread`相同，有自带的异常捕获、广播机制，以及加入了MiraiCP的平台错误处理机制的支持，除此之外以外没有区别。

### 异常

请不要在插件主线程中抛出没有继承`std::exception`的异常（如throw一个字符串等）！抛出`std::exception`（直接、间接）子类对象的异常时，插件将自行处理该异常并压制，插件仍然可以正常运行。但如果插件抛出了其他类型的异常，将导致插件的异常被libloader端捕获，libloader将强制卸载该插件，这在多线程的情况下可能导致段错误等更加严重的问题。如果有需要，请参考MiraiCP的异常API。
